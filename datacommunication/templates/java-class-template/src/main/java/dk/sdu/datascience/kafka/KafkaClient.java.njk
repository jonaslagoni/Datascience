
package dk.sdu.datascience.kafka;

import dk.sdu.datascience.kafka.structure.messages.*;
import org.apache.kafka.clients.producer.*;
import org.apache.kafka.common.serialization.LongSerializer;
import org.apache.kafka.common.serialization.StringSerializer;
import java.util.Properties;
import com.google.gson.Gson;
import java.util.Collections;
import java.util.concurrent.ExecutionException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
public class KafkaClient{
{%- for channelName, channel in asyncapi.channels() %}
	{%- if channel.hasPublish() %}
    /**
     * {{channel.description()}}
     * @param {{channel.publish().message().name()}} to send as payload
     */
	public static void produce{{channelName | camelCase}}({{channel.publish().message().name() | upperFirst}} {{channel.publish().message().name()}}) {
		final Producer<Long, String> producer = ProducerCreator.createProducer();
		long time = System.currentTimeMillis();
		Gson gson = new Gson();
		String payload = gson.toJson({{channel.publish().message().name()}});
		try {
			final ProducerRecord<Long, String> record =
					new ProducerRecord<>("{{channelName | camelCase}}",
								payload);

			RecordMetadata metadata = producer.send(record).get();

			long elapsedTime = System.currentTimeMillis() - time;
			System.out.printf("sent record(key=%s value=%s) " +
							"meta(partition=%d, offset=%d) time=%d\n",
					record.key(), record.value(), metadata.partition(),
					metadata.offset(), elapsedTime);
		} catch (ExecutionException ex) {
            Logger.getLogger(KafkaClient.class.getName()).log(Level.SEVERE, null, ex);
        } catch (InterruptedException ex) {
            Logger.getLogger(KafkaClient.class.getName()).log(Level.SEVERE, null, ex);
        }  finally {
			producer.flush();
			producer.close();
		}
	}
	{%- elif  channel.hasSubscribe() %}
	public interface {{channelName | camelCase}}Callback { 
		// this can be any type of method 
		void messageConsumed({{channel.subscribe().message().name() | upperFirst}} payload); 
	} 

    /**
    * {{channel.description()}}
    * @param callback which should be called when data is consumed
    */
    public static void consumer{{channel.subscribe().message().name() | upperFirst}}({{channelName | camelCase}}Callback callback) {
        Thread thread = new Thread(() -> {
            Consumer<Long, String> consumer = ConsumerCreator.createConsumer();
            consumer.subscribe(Collections.singletonList("energidataCo2Emission"));
            while(true){
                consumerEnerginetCO2Emission(consumer, callback);
            }
        });
        thread.start();
    }

    private static void consumer{{channel.subscribe().message().name() | upperFirst}}(Consumer<Long, String> consumer,{{channelName | camelCase}}Callback callback) {
            consumer.subscribe(Collections.singletonList("{{channelName | camelCase}}"));
            ConsumerRecords<Long, String> consumerRecords = consumer.poll(1000);
            // 1000 is the time in milliseconds consumer will wait if no record is found at broker.
            if (consumerRecords.count() == 0) {
                System.out.println("No records found");
                return;
            }
            Gson gson = new Gson();
            //print each record.
            ConsumerRecord consumerRecord = null;
            while (consumerRecords.iterator().hasNext()) {
                consumerRecord = consumerRecords.iterator().next();
                System.out.println("Record Key " + consumerRecord.key());
                System.out.println("Record value " + consumerRecord.value());
                System.out.println("Record partition " + consumerRecord.partition());
                System.out.println("Record offset " + consumerRecord.offset());
            }
            if (consumerRecord != null) {
                {{channel.subscribe().message().name() | upperFirst}} data = gson.fromJson("" + consumerRecord.value(), {{channel.subscribe().message().name() | upperFirst}}.class);
                callback.messageConsumed(data);
            }
            // commits the offset of record to broker.
            consumer.commitAsync();
        }
	{%- endif %}
{%- endfor %}
}


